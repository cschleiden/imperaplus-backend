/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v8.6.6221.23503 (NJsonSchema v7.6.6221.22528) (http://NSwag.org)
// </auto-generated>
//----------------------


export class AccountClient {
    private baseUrl: string; 
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    exchange(grant_type: string, username: string, password: string, scope: string, refresh_token: string): Promise<LoginResponseModel> {
        let url_ = this.baseUrl + "/api/Account/token?";
        if (grant_type !== undefined)
        
            url_ += "grant_type=" + encodeURIComponent("" + grant_type) + "&"; 
        
        if (username !== undefined)
        
            url_ += "username=" + encodeURIComponent("" + username) + "&"; 
        
        if (password !== undefined)
        
            url_ += "password=" + encodeURIComponent("" + password) + "&"; 
        
        if (scope !== undefined)
        
            url_ += "scope=" + encodeURIComponent("" + scope) + "&"; 
        
        if (refresh_token !== undefined)
        
            url_ += "refresh_token=" + encodeURIComponent("" + refresh_token) + "&";

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processExchange(response);
        });
    }

    protected processExchange(response: Response): Promise<LoginResponseModel> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: LoginResponseModel = null;
                result200 = responseText === "" ? null : <LoginResponseModel>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Checks if a username is available
     * @userName Username to check
     * @return True if username is available
     */
    getUserNameAvailable(userName: string): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/UserNameAvailable?";
        if (userName === undefined)
            throw new Error("The parameter 'userName' must be defined.");
        else
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetUserNameAvailable(response);
        });
    }

    protected processGetUserNameAvailable(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get user information
     */
    getUserInfo(): Promise<UserInfo> {
        let url_ = this.baseUrl + "/api/Account/UserInfo";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetUserInfo(response);
        });
    }

    protected processGetUserInfo(response: Response): Promise<UserInfo> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: UserInfo = null;
                result200 = responseText === "" ? null : <UserInfo>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get user information for an external user (i.e., just logged in using an external provider)
     */
    getExternalUserInfo(): Promise<UserInfo> {
        let url_ = this.baseUrl + "/api/Account/ExternalUserInfo";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetExternalUserInfo(response);
        });
    }

    protected processGetExternalUserInfo(response: Response): Promise<UserInfo> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: UserInfo = null;
                result200 = responseText === "" ? null : <UserInfo>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    logout(): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/Logout";

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processLogout(response);
        });
    }

    protected processLogout(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    getManageInfo(returnUrl: string, generateState: boolean): Promise<ManageInfoViewModel> {
        let url_ = this.baseUrl + "/api/Account/ManageInfo?";
        if (returnUrl === undefined)
            throw new Error("The parameter 'returnUrl' must be defined.");
        else
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        
        if (generateState === null)
            throw new Error("The parameter 'generateState' cannot be null.");
        else if (generateState !== undefined)
            url_ += "generateState=" + encodeURIComponent("" + generateState) + "&";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetManageInfo(response);
        });
    }

    protected processGetManageInfo(response: Response): Promise<ManageInfoViewModel> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: ManageInfoViewModel = null;
                result200 = responseText === "" ? null : <ManageInfoViewModel>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    changePassword(model: ChangePasswordBindingModel): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/ChangePassword";

        const content_ = JSON.stringify(model);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processChangePassword(response);
        });
    }

    protected processChangePassword(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    setPassword(model: SetPasswordBindingModel): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/SetPassword";

        const content_ = JSON.stringify(model);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processSetPassword(response);
        });
    }

    protected processSetPassword(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    removeLogin(model: RemoveLoginBindingModel): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/RemoveLogin";

        const content_ = JSON.stringify(model);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processRemoveLogin(response);
        });
    }

    protected processRemoveLogin(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    getExternalLogins(returnUrl: string, generateState: boolean): Promise<ExternalLoginViewModel[]> {
        let url_ = this.baseUrl + "/api/Account/ExternalLogins?";
        if (returnUrl === undefined)
            throw new Error("The parameter 'returnUrl' must be defined.");
        else
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        
        if (generateState === null)
            throw new Error("The parameter 'generateState' cannot be null.");
        else if (generateState !== undefined)
            url_ += "generateState=" + encodeURIComponent("" + generateState) + "&";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetExternalLogins(response);
        });
    }

    protected processGetExternalLogins(response: Response): Promise<ExternalLoginViewModel[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: ExternalLoginViewModel[] = null;
                result200 = responseText === "" ? null : <ExternalLoginViewModel[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    register(model: RegisterBindingModel): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/Register";

        const content_ = JSON.stringify(model);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processRegister(response);
        });
    }

    protected processRegister(response: Response): Promise<void> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                return null;
            } else if (status === 400) {
                let result400: ErrorResponse = null;
                result400 = responseText === "" ? null : <ErrorResponse>JSON.parse(responseText, this.jsonParseReviver);
                this.throwException("A server error occurred.", status, responseText, result400);
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Resend the email confirmation account to the given user account
     */
    resendConfirmationCode(model: ResendConfirmationModel): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/ResendConfirmation";

        const content_ = JSON.stringify(model);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processResendConfirmationCode(response);
        });
    }

    protected processResendConfirmationCode(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Confirm user account using code provided in mail
     * @model Model containing id and code
     * @return Success if successfully activated
     */
    confirmEmail(model: ConfirmationModel): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/ConfirmEmail";

        const content_ = JSON.stringify(model);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processConfirmEmail(response);
        });
    }

    protected processConfirmEmail(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Request password reset link
     */
    forgotPassword(model: ForgotPasswordViewModel): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/ForgotPassword";

        const content_ = JSON.stringify(model);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processForgotPassword(response);
        });
    }

    protected processForgotPassword(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Reset password confirmation
     */
    resetPassword(model: ResetPasswordViewModel): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/ResetPassword";

        const content_ = JSON.stringify(model);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processResetPassword(response);
        });
    }

    protected processResetPassword(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Create user accout for an external login
     */
    registerExternal(model: RegisterExternalBindingModel): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/RegisterExternal";

        const content_ = JSON.stringify(model);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processRegisterExternal(response);
        });
    }

    protected processRegisterExternal(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response);
    }
}

export class GameClient {
    private baseUrl: string; 
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    /**
     * Get a list of open games, excluding games by the current player
     * @return List of games
     */
    getAll(): Promise<GameSummary[]> {
        let url_ = this.baseUrl + "/api/games/open";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetAll(response);
        });
    }

    protected processGetAll(response: Response): Promise<GameSummary[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameSummary[] = null;
                result200 = responseText === "" ? null : <GameSummary[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get a list of the games for the current player
     * @return List of games for the current user
     */
    getMy(): Promise<GameSummary[]> {
        let url_ = this.baseUrl + "/api/games/my";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetMy(response);
        });
    }

    protected processGetMy(response: Response): Promise<GameSummary[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameSummary[] = null;
                result200 = responseText === "" ? null : <GameSummary[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get list of games where it's the current player's team
     * @return List of games where it's the current user's team
     */
    getMyTurn(): Promise<GameSummary[]> {
        let url_ = this.baseUrl + "/api/games/myturn";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetMyTurn(response);
        });
    }

    protected processGetMyTurn(response: Response): Promise<GameSummary[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameSummary[] = null;
                result200 = responseText === "" ? null : <GameSummary[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Create a new game
     * @creationOptions Creation options
     * @return Summary of newly created game
     */
    post(creationOptions: GameCreationOptions): Promise<GameSummary> {
        let url_ = this.baseUrl + "/api/games";

        const content_ = JSON.stringify(creationOptions);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPost(response);
        });
    }

    protected processPost(response: Response): Promise<GameSummary> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameSummary = null;
                result200 = responseText === "" ? null : <GameSummary>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get detailed information about a single game
     * @gameId Id of the requested game
     * @return Information about the requested game
     */
    get(gameId: number): Promise<Game> {
        let url_ = this.baseUrl + "/api/games/{gameId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGet(response);
        });
    }

    protected processGet(response: Response): Promise<Game> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: Game = null;
                result200 = responseText === "" ? null : <Game>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Cancel/delete the requested game, if possible.
     * @gameId Id of the game to delete
     * @return Status
     */
    delete(gameId: number): Promise<any> {
        let url_ = this.baseUrl + "/api/games/{gameId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processDelete(response);
        });
    }

    protected processDelete(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get messages for a single game
     * @gameId Id of the requested game
     * @isPublic Value indicating whether to return only public messages, default is true
     * @return Messages posted in the requested game
     */
    getMessages(gameId: number, isPublic: boolean): Promise<Game> {
        let url_ = this.baseUrl + "/api/games/{gameId}/messages?";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        
        if (isPublic === null)
            throw new Error("The parameter 'isPublic' cannot be null.");
        else if (isPublic !== undefined)
            url_ += "isPublic=" + encodeURIComponent("" + isPublic) + "&";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetMessages(response);
        });
    }

    protected processGetMessages(response: Response): Promise<Game> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: Game = null;
                result200 = responseText === "" ? null : <Game>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Join the given game
     * @gameId Id of game to join
     */
    postJoin(gameId: number): Promise<any> {
        let url_ = this.baseUrl + "/api/games/{gameId}/join";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPostJoin(response);
        });
    }

    protected processPostJoin(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Leave the given game, only possible if game hasn't started yet, and current player
is not the creator.
     * @gameId Id of game to leave
     */
    postLeave(gameId: number): Promise<any> {
        let url_ = this.baseUrl + "/api/games/{gameId}/leave";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPostLeave(response);
        });
    }

    protected processPostLeave(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Surrender in the given game, only possible if current player
and game are still active.
     * @gameId Id of game to surrender in
     */
    postSurrender(gameId: number): Promise<GameSummary> {
        let url_ = this.baseUrl + "/api/games/{gameId}/surrender";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPostSurrender(response);
        });
    }

    protected processPostSurrender(response: Response): Promise<GameSummary> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameSummary = null;
                result200 = responseText === "" ? null : <GameSummary>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Hides the given game for the current player
     * @gameId Id of game to hide
     */
    patchHide(gameId: number): Promise<any> {
        let url_ = this.baseUrl + "/api/games/{gameId}/hide";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPatchHide(response);
        });
    }

    protected processPatchHide(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Hide all games which can be hidden for the current player
     */
    patchHideAll(): Promise<any> {
        let url_ = this.baseUrl + "/api/games/hide";

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPatchHideAll(response);
        });
    }

    protected processPatchHideAll(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response);
    }
}

export class HistoryClient {
    private baseUrl: string; 
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    /**
     * Gets the specified turn including the actions and current state of the map
     */
    getTurn(gameId: number, turnId: number): Promise<HistoryTurn> {
        let url_ = this.baseUrl + "/api/games/{gameId}/history/{turnId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        
        if (turnId === undefined || turnId === null)
            throw new Error("The parameter 'turnId' must be defined.");
        url_ = url_.replace("{turnId}", encodeURIComponent("" + turnId));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetTurn(response);
        });
    }

    protected processGetTurn(response: Response): Promise<HistoryTurn> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: HistoryTurn = null;
                result200 = responseText === "" ? null : <HistoryTurn>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response);
    }
}

export class LadderClient {
    private baseUrl: string; 
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    /**
     * Returns active ladders
     * @return List of ladders
     */
    getAll(): Promise<LadderSummary[]> {
        let url_ = this.baseUrl + "/api/ladder";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetAll(response);
        });
    }

    protected processGetAll(response: Response): Promise<LadderSummary[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: LadderSummary[] = null;
                result200 = responseText === "" ? null : <LadderSummary[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Gets ladder identified by given id
     * @ladderId Id of ladder
     */
    get(ladderId: string): Promise<Ladder> {
        let url_ = this.baseUrl + "/api/ladder/{ladderId}";
        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url_ = url_.replace("{ladderId}", encodeURIComponent("" + ladderId));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGet(response);
        });
    }

    protected processGet(response: Response): Promise<Ladder> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: Ladder = null;
                result200 = responseText === "" ? null : <Ladder>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Queue up for a new game in the given ladder
     * @ladderId Ladder id
     * @return Status
     */
    postJoin(ladderId: string): Promise<any> {
        let url_ = this.baseUrl + "/api/ladder/{ladderId}/queue";
        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url_ = url_.replace("{ladderId}", encodeURIComponent("" + ladderId));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPostJoin(response);
        });
    }

    protected processPostJoin(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Gets ladder standings
     * @ladderId Id of ladder
     * @start Items to skip before returning
     * @count Count of standings to return
     */
    getStandings(ladderId: string, start: number, count: number): Promise<LadderStanding[]> {
        let url_ = this.baseUrl + "/api/ladder/{ladderId}/standings?";
        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url_ = url_.replace("{ladderId}", encodeURIComponent("" + ladderId)); 
        
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&"; 
        
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetStandings(response);
        });
    }

    protected processGetStandings(response: Response): Promise<LadderStanding[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: LadderStanding[] = null;
                result200 = responseText === "" ? null : <LadderStanding[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response);
    }
}

export class MapClient {
    private baseUrl: string; 
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    getAllSummary(): Promise<MapTemplateDescriptor[]> {
        let url_ = this.baseUrl + "/api/map";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetAllSummary(response);
        });
    }

    protected processGetAllSummary(response: Response): Promise<MapTemplateDescriptor[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: MapTemplateDescriptor[] = null;
                result200 = responseText === "" ? null : <MapTemplateDescriptor[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get map template identified by name
     */
    getMapTemplate(name: string): Promise<MapTemplate> {
        let url_ = this.baseUrl + "/api/map/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetMapTemplate(response);
        });
    }

    protected processGetMapTemplate(response: Response): Promise<MapTemplate> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: MapTemplate = null;
                result200 = responseText === "" ? null : <MapTemplate>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response);
    }
}

export class MessageClient {
    private baseUrl: string; 
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    getAll(messageFolder: MessageFolder, folder: string): Promise<Message[]> {
        let url_ = this.baseUrl + "/api/messages/folder/{folder}?";
        if (folder === undefined || folder === null)
            throw new Error("The parameter 'folder' must be defined.");
        url_ = url_.replace("{folder}", encodeURIComponent("" + folder)); 
        
        if (messageFolder === null)
            throw new Error("The parameter 'messageFolder' cannot be null.");
        else if (messageFolder !== undefined)
            url_ += "messageFolder=" + encodeURIComponent("" + messageFolder) + "&";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetAll(response);
        });
    }

    protected processGetAll(response: Response): Promise<Message[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: Message[] = null;
                result200 = responseText === "" ? null : <Message[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    get(messageId: string): Promise<Message> {
        let url_ = this.baseUrl + "/api/messages/{messageId}";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGet(response);
        });
    }

    protected processGet(response: Response): Promise<Message> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: Message = null;
                result200 = responseText === "" ? null : <Message>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    patchMarkRead(messageId: string): Promise<any> {
        let url_ = this.baseUrl + "/api/messages/{messageId}";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPatchMarkRead(response);
        });
    }

    protected processPatchMarkRead(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    delete(messageId: string): Promise<any> {
        let url_ = this.baseUrl + "/api/messages/{messageId}";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processDelete(response);
        });
    }

    protected processDelete(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    getFolderInformation(): Promise<FolderInformation> {
        let url_ = this.baseUrl + "/api/messages/folders";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetFolderInformation(response);
        });
    }

    protected processGetFolderInformation(response: Response): Promise<FolderInformation> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: FolderInformation = null;
                result200 = responseText === "" ? null : <FolderInformation>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    postSend(message: SendMessage): Promise<any> {
        let url_ = this.baseUrl + "/api/messages";

        const content_ = JSON.stringify(message);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPostSend(response);
        });
    }

    protected processPostSend(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response);
    }
}

export class NewsClient {
    private baseUrl: string; 
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    /**
     * Returns the last 10 news items for all languages
     * @return List of news items
     */
    getAll(): Promise<NewsItem[]> {
        let url_ = this.baseUrl + "/api/news";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetAll(response);
        });
    }

    protected processGetAll(response: Response): Promise<NewsItem[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: NewsItem[] = null;
                result200 = responseText === "" ? null : <NewsItem[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response);
    }
}

export class NotificationClient {
    private baseUrl: string; 
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    /**
     * Get notification summary for current user
     */
    getSummary(): Promise<any> {
        let url_ = this.baseUrl + "/api/notifications/summary";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetSummary(response);
        });
    }

    protected processGetSummary(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response);
    }
}

export class PlayClient {
    private baseUrl: string; 
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    /**
     * Place units to countries.
     * @gameId Id of the game
     * @placeUnitsOptions List of country/unit count pairs
     * @return GameActionResult of action
     */
    postPlace(gameId: number, placeUnitsOptions: PlaceUnitsOptions[]): Promise<GameActionResult> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/place";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));

        const content_ = JSON.stringify(placeUnitsOptions);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPostPlace(response);
        });
    }

    protected processPostPlace(response: Response): Promise<GameActionResult> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameActionResult = null;
                result200 = responseText === "" ? null : <GameActionResult>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Exchange cards for the current player. Which cards to exchange is automatically chosen to gain the most bonus for the player.
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postExchange(gameId: number): Promise<GameActionResult> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/exchange";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPostExchange(response);
        });
    }

    protected processPostExchange(response: Response): Promise<GameActionResult> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameActionResult = null;
                result200 = responseText === "" ? null : <GameActionResult>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Attack from one to another country.
     * @gameId Id of the game
     * @options Options for the command
     * @return GameActionResult of action
     */
    postAttack(gameId: number, options: AttackOptions): Promise<GameActionResult> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/attack";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));

        const content_ = JSON.stringify(options);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPostAttack(response);
        });
    }

    protected processPostAttack(response: Response): Promise<GameActionResult> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameActionResult = null;
                result200 = responseText === "" ? null : <GameActionResult>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Switch to moving.
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postEndAttack(gameId: number): Promise<GameActionResult> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/endattack";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPostEndAttack(response);
        });
    }

    protected processPostEndAttack(response: Response): Promise<GameActionResult> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameActionResult = null;
                result200 = responseText === "" ? null : <GameActionResult>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Move units between countries. Only allowed after placing. Cancels any attacks that the player had left before. Attacking is not
possible anymore after moving.
     * @gameId Id of the game
     * @options Options for the command
     * @return GameActionResult of action
     */
    postMove(gameId: number, options: MoveOptions): Promise<GameActionResult> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/move";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));

        const content_ = JSON.stringify(options);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPostMove(response);
        });
    }

    protected processPostMove(response: Response): Promise<GameActionResult> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameActionResult = null;
                result200 = responseText === "" ? null : <GameActionResult>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * End the current turn
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postEndTurn(gameId: number): Promise<Game> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/endturn";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPostEndTurn(response);
        });
    }

    protected processPostEndTurn(response: Response): Promise<Game> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: Game = null;
                result200 = responseText === "" ? null : <Game>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response);
    }
}

export class TournamentClient {
    private baseUrl: string; 
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    /**
     * Returns tournaments
     * @return List of tournaments
     */
    getAll(): Promise<Tournament[]> {
        let url_ = this.baseUrl + "/api/tournaments";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetAll(response);
        });
    }

    protected processGetAll(response: Response): Promise<Tournament[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: Tournament[] = null;
                result200 = responseText === "" ? null : <Tournament[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get tournament identified by Id
     * @tournamentId Id of tournament
     */
    getById(tournamentId: string): Promise<Tournament> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetById(response);
        });
    }

    protected processGetById(response: Response): Promise<Tournament> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: Tournament = null;
                result200 = responseText === "" ? null : <Tournament>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Join tournament
     * @tournamentId Id of tournament
     */
    postJoin(tournamentId: string): Promise<TournamentTeam> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPostJoin(response);
        });
    }

    protected processPostJoin(response: Response): Promise<TournamentTeam> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: TournamentTeam = null;
                result200 = responseText === "" ? null : <TournamentTeam>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get teams for tournament
     * @tournamentId Id of tournament
     */
    getTeams(tournamentId: string): Promise<TournamentTeam[]> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetTeams(response);
        });
    }

    protected processGetTeams(response: Response): Promise<TournamentTeam[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: TournamentTeam[] = null;
                result200 = responseText === "" ? null : <TournamentTeam[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Create new team for a tournament
     * @tournamentId Id of tournament
     * @name Name of team
     * @password Optional password for team
     * @return Summary of newly created team
     */
    postCreateTeam(tournamentId: string, name: string, password: string): Promise<TournamentTeamSummary> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams?";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 
        
        if (name === undefined)
            throw new Error("The parameter 'name' must be defined.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        
        if (password !== undefined)
        
            url_ += "password=" + encodeURIComponent("" + password) + "&";

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPostCreateTeam(response);
        });
    }

    protected processPostCreateTeam(response: Response): Promise<TournamentTeamSummary> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: TournamentTeamSummary = null;
                result200 = responseText === "" ? null : <TournamentTeamSummary>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Join existing team
     * @tournamentId Id of tournament
     * @teamId Id of team
     * @password Optional password for team to join
     */
    postJoinTeam(tournamentId: string, teamId: string, password: string): Promise<any> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams/{teamId}?";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 
        
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        
        if (password !== undefined)
        
            url_ += "password=" + encodeURIComponent("" + password) + "&";

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPostJoinTeam(response);
        });
    }

    protected processPostJoinTeam(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Delete a team. Only allowed if user created it
     * @tournamentId Id of tournament
     * @teamId Id of team to delete
     */
    deleteTeam(tournamentId: string, teamId: string): Promise<any> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams/{teamId}";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 
        
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processDeleteTeam(response);
        });
    }

    protected processDeleteTeam(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Leave a team and tournament
     * @tournamentId Id of tournament
     */
    leaveTournament(tournamentId: string): Promise<any> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams/me";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processLeaveTournament(response);
        });
    }

    protected processLeaveTournament(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response);
    }
}

export class UserClient {
    private baseUrl: string; 
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    /**
     * Find users starting with the given query
     * @query Query to search for
     */
    findUsers(query: string): Promise<UserReference[]> {
        let url_ = this.baseUrl + "/api/users/find/{query}";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined.");
        url_ = url_.replace("{query}", encodeURIComponent("" + query));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
				"Accept": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processFindUsers(response);
        });
    }

    protected processFindUsers(response: Response): Promise<UserReference[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: UserReference[] = null;
                result200 = responseText === "" ? null : <UserReference[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response);
    }
}

export interface LoginResponseModel {
    access_token: string;
    refresh_token: string;
}

export interface UserInfo {
    userId: string;
    userName: string;
    hasRegistered: boolean;
    loginProvider: string;
    language: string;
    roles: string[];
}

export interface ManageInfoViewModel {
    localLoginProvider: string;
    userName: string;
    logins: UserLoginInfoViewModel[];
    externalLoginProviders: ExternalLoginViewModel[];
}

export interface UserLoginInfoViewModel {
    loginProvider: string;
    providerKey: string;
}

export interface ExternalLoginViewModel {
    name: string;
    url: string;
    state: string;
}

export interface ChangePasswordBindingModel {
    oldPassword: string;
    newPassword: string;
    confirmPassword: string;
}

export interface SetPasswordBindingModel {
    newPassword: string;
    confirmPassword: string;
}

export interface RemoveLoginBindingModel {
    loginProvider: string;
    providerKey: string;
}

export interface RegisterBindingModel {
    userName: string;
    password: string;
    confirmPassword: string;
    email: string;
    language: string;
    callbackUrl: string;
}

export interface ErrorResponse {
    error: string;
    error_Description: string;
    parameter_Errors: { [key: string] : string[]; };
}

export interface ResendConfirmationModel {
    callbackUrl: string;
    userName: string;
    password: string;
    language: string;
}

export interface ConfirmationModel {
    userId: string;
    code: string;
}

export interface ForgotPasswordViewModel {
    callbackUrl: string;
    userName: string;
    email: string;
    language: string;
}

export interface ResetPasswordViewModel {
    userId: string;
    password: string;
    confirmPassword: string;
    code: string;
}

export interface RegisterExternalBindingModel {
    userName: string;
    email: string;
}

export interface GameSummary {
    id: number;
    type: GameType;
    name: string;
    ladderId: string;
    ladderName: string;
    options: GameOptions;
    createdByUserId: string;
    createdByName: string;
    startedAt: Date;
    lastActionAt: Date;
    timeoutSecondsLeft: number;
    mapTemplate: string;
    state: GameState;
    currentPlayer: PlayerSummary;
    teams: TeamSummary[];
}

export enum GameType {
    Fun = <any>"Fun", 
    Ranking = <any>"Ranking", 
    Tournament = <any>"Tournament", 
}

export interface GameOptions {
    numberOfPlayersPerTeam: number;
    numberOfTeams: number;
    minUnitsPerCountry: number;
    newUnitsPerTurn: number;
    attacksPerTurn: number;
    movesPerTurn: number;
    initialCountryUnits: number;
    mapDistribution: MapDistribution;
    timeoutInSeconds: number;
    maximumTimeoutsPerPlayer: number;
    maximumNumberOfCards: number;
    victoryConditions: VictoryConditionType[];
    visibilityModifier: VisibilityModifierType[];
}

export enum MapDistribution {
    Default = <any>"Default", 
    Malibu = <any>"Malibu", 
    TeamCluster = <any>"TeamCluster", 
}

export enum VictoryConditionType {
    Survival = <any>"Survival", 
    ControlContinent = <any>"ControlContinent", 
}

export enum VisibilityModifierType {
    None = <any>"None", 
    Fog = <any>"Fog", 
}

export enum GameState {
    None = <any>"None", 
    Open = <any>"Open", 
    Active = <any>"Active", 
    Ended = <any>"Ended", 
}

export interface PlayerSummary {
    id: string;
    userId: string;
    name: string;
    state: PlayerState;
    outcome: PlayerOutcome;
    teamId: string;
    playOrder: number;
    timeouts: number;
}

export enum PlayerState {
    None = <any>"None", 
    Active = <any>"Active", 
    InActive = <any>"InActive", 
}

export enum PlayerOutcome {
    None = <any>"None", 
    Won = <any>"Won", 
    Defeated = <any>"Defeated", 
    Surrendered = <any>"Surrendered", 
    Timeout = <any>"Timeout", 
}

export interface TeamSummary {
    id: string;
    playOrder: number;
    players: PlayerSummary[];
}

export interface GameCreationOptions extends GameOptions {
    name: string;
    addBot: boolean;
    mapTemplate: string;
}

export interface Game {
    id: number;
    type: GameType;
    name: string;
    mapTemplate: string;
    teams: Team[];
    state: GameState;
    playState: PlayState;
    currentPlayer: PlayerSummary;
    map: Map;
    options: GameOptions;
    lastModifiedAt: Date;
    timeoutSecondsLeft: number;
    turnCounter: number;
    unitsToPlace: number;
    attacksInCurrentTurn: number;
    movesInCurrentTurn: number;
}

export interface Team {
    id: string;
    playOrder: number;
    players: Player[];
}

export interface Player extends PlayerSummary {
    cards: BonusCard[];
    placedInitialUnits: boolean;
    numberOfUnits: number;
    numberOfCountries: number;
}

export enum BonusCard {
    A = <any>"A", 
    B = <any>"B", 
    C = <any>"C", 
}

export enum PlayState {
    None = <any>"None", 
    PlaceUnits = <any>"PlaceUnits", 
    Attack = <any>"Attack", 
    Move = <any>"Move", 
    Done = <any>"Done", 
}

export interface Map {
    countries: Country[];
}

export interface Country {
    identifier: string;
    playerId: string;
    teamId: string;
    units: number;
}

export interface HistoryTurn {
    gameId: number;
    turnId: number;
    actions: HistoryEntry[];
    game: Game;
}

export interface HistoryEntry {
    id: number;
    turnNo: number;
    dateTime: Date;
    actorId: string;
    otherPlayerId: string;
    action: HistoryAction;
    originIdentifier: string;
    destinationIdentifier: string;
    units: number;
    unitsLost: number;
    unitsLostOther: number;
    result: boolean;
}

export enum HistoryAction {
    None = <any>"None", 
    StartGame = <any>"StartGame", 
    EndGame = <any>"EndGame", 
    PlaceUnits = <any>"PlaceUnits", 
    Attack = <any>"Attack", 
    Move = <any>"Move", 
    ExchangeCards = <any>"ExchangeCards", 
    PlayerLost = <any>"PlayerLost", 
    PlayerWon = <any>"PlayerWon", 
    PlayerTimeout = <any>"PlayerTimeout", 
    OwnerChange = <any>"OwnerChange", 
    EndTurn = <any>"EndTurn", 
}

export interface LadderSummary {
    id: string;
    name: string;
    options: GameOptions;
    standing: LadderStanding;
    isQueued: boolean;
    queueCount: number;
    mapTemplates: string[];
}

export interface LadderStanding {
    userId: string;
    userName: string;
    position: number;
    gamesPlayed: number;
    gamesWon: number;
    gamesLost: number;
    rating: number;
    lastGame: Date;
}

export interface Ladder extends LadderSummary {
    standings: LadderStanding[];
    isActive: boolean;
}

export interface MapTemplateDescriptor {
    name: string;
}

export interface MapTemplate {
    name: string;
    image: string;
    countries: CountryTemplate[];
    connections: Connection[];
    continents: Continent[];
}

export interface CountryTemplate {
    identifier: string;
    name: string;
    x: number;
    y: number;
}

export interface Connection {
    origin: string;
    destination: string;
}

export interface Continent {
    id: number;
    name: string;
    bonus: number;
    countries: string[];
}

export enum MessageFolder {
    None = <any>"None", 
    Inbox = <any>"Inbox", 
    Sent = <any>"Sent", 
}

export interface SendMessage {
    to: UserReference;
    subject: string;
    text: string;
}

export interface Message extends SendMessage {
    id: string;
    from: UserReference;
    folder: MessageFolder;
    sentAt: Date;
    isRead: boolean;
}

export interface UserReference {
    id: string;
    name: string;
}

export interface FolderInformation {
    folder: MessageFolder;
    count: number;
    unreadCount: number;
}

export interface NewsItem {
    dateTime: Date;
    postedBy: string;
    content: NewsContent[];
}

export interface NewsContent {
    language: string;
    title: string;
    text: string;
}

export interface PlaceUnitsOptions {
    countryIdentifier: string;
    numberOfUnits: number;
}

export interface GameActionResult {
    id: number;
    teams: Team[];
    state: GameState;
    playState: PlayState;
    countryUpdates: Country[];
    actionResult: ActionResult;
    attacksInCurrentTurn: number;
    movesInCurrentTurn: number;
    cards: BonusCard[];
    currentPlayer: Player;
}

export enum ActionResult {
    None = <any>"None", 
    Successful = <any>"Successful", 
    NotSuccessful = <any>"NotSuccessful", 
}

export interface AttackOptions {
    originCountryIdentifier: string;
    destinationCountryIdentifier: string;
    numberOfUnits: number;
}

export interface MoveOptions {
    originCountryIdentifier: string;
    destinationCountryIdentifier: string;
    numberOfUnits: number;
}

export interface TournamentSummary {
    id: string;
    name: string;
    state: TournamentState;
    options: GameOptions;
    numberOfTeams: number;
    numberOfGroupGames: number;
    numberOfKnockoutGames: number;
    numberOfFinalGames: number;
    startOfRegistration: Date;
    startOfTournament: Date;
    endOfTournament: Date;
    completion: number;
}

export interface Tournament extends TournamentSummary {
    teams: TournamentTeam[];
    groups: TournamentGroup[];
    pairings: TournamentPairing[];
    mapTemplates: string[];
    winner: TournamentTeam;
    phase: number;
}

export interface TournamentTeamSummary {
    id: string;
    name: string;
    groupOrder: number;
    state: TournamentTeamState;
}

export interface TournamentTeam extends TournamentTeamSummary {
    participants: UserReference[];
}

export enum TournamentTeamState {
    Open = <any>"Open", 
    Active = <any>"Active", 
    InActive = <any>"InActive", 
}

export interface TournamentGroup {
    id: string;
    teams: TournamentTeamSummary[];
}

export interface TournamentPairing {
    teamA: TournamentTeamSummary;
    teamB: TournamentTeamSummary;
    teamAWon: number;
    teamBWon: number;
    numberOfGames: number;
    phase: number;
    order: number;
}

export enum TournamentState {
    Open = <any>"Open", 
    Groups = <any>"Groups", 
    Knockout = <any>"Knockout", 
    Closed = <any>"Closed", 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    result?: any; 

    constructor(message: string, status: number, response: string, result?: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.result = result;
    }
}